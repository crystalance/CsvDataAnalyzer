# CSV 数据分析系统

基于大语言模型的 Code Interpreter 风格数据分析系统。

[English](README.md) | 中文

## 项目简介

### 这是什么？

本项目实现了 **Code Interpreter** 模式 - 一个能够：
1. 接收用户的自然语言问题
2. 自动生成 Python 代码来回答问题
3. 在沙箱环境中执行代码
4. 返回结果（文本、表格、图表）给用户

### 为什么要做这个？

受 OpenAI Code Interpreter（现称 Advanced Data Analysis）启发，本项目展示如何用开源组件构建类似系统：

- **降低数据分析门槛**：用户无需会写 Python 就能分析数据
- **推理过程透明**：不同于黑箱 AI，用户可以看到并验证生成的代码
- **自动纠错迭代**：系统能从执行错误中学习并自动修正

---

## 系统设计

### 架构总览

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Gradio Web UI                                  │
│                           (app.py - 前端界面)                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                             CSVAnalyzer                                     │
│                        (analyzer.py - 核心调度器)                             │
│  ┌─────────────────────────────────────────────────────────────────────┐    │
│  │  • 管理对话历史                                                       │    │
│  │  • 协调 LLM 和执行器                                                  │    │
│  │  • 实现带错误反馈的重试逻辑                                             │    │
│  └─────────────────────────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────────────────────────┘
                          │                    │
                          ▼                    ▼
┌─────────────────────────────────┐  ┌─────────────────────────────────────────┐
│         LLM 层                  │  │              核心层                      │
│         (llm/)                  │  │              (core/)                    │
│  ┌───────────────────────────┐  │  │  ┌─────────────────────────────────┐    │
│  │  BaseLLM (抽象基类)        │  │  │  │  CodeExecutor                   │    │
│  │    ├── QwenLLM            │  │  │  │  • 沙箱代码执行                   │    │
│  │    ├── OpenAILLM          │  │  │  │  • 输出/图表捕获                  │    │
│  │    └── DeepSeekLLM        │  │  │  └─────────────────────────────────┘    │
│  └───────────────────────────┘  │  │  ┌─────────────────────────────────┐    │
│                                 │  │  │  ErrorHandler                   │    │
│                                 │  │  │  • 错误分类                      │    │
│                                 │  │  │  • 针对性修复建议                 │    │
│                                 │  │  └─────────────────────────────────┘    │
│                                 │  │  ┌─────────────────────────────────┐    │
│                                 │  │  │  PromptBuilder                  │    │
│                                 │  │  │  • 系统提示词                     │    │
│                                 │  │  │  • 错误纠正提示词                 │    │
│                                 │  │  └─────────────────────────────────┘    │
└─────────────────────────────────┘  └─────────────────────────────────────────┘
```

### 请求流程

```
用户问题: "各地区的平均销售额是多少？"
                              │
                              ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│ 步骤 1: 构建上下文                                                              │
│ ┌──────────────────────────────────────────────────────────────────────────┐ │
│ │ 系统提示词 + CSV Schema + 对话历史 + 用户问题                                │ │
│ └──────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│ 步骤 2: LLM 生成代码                                                           │
│ ┌──────────────────────────────────────────────────────────────────────────┐ │
│ │ ```python                                                                │ │
│ │ df = pd.read_csv(csv_path)                                               │ │
│ │ result = df.groupby('Region')['Sales'].mean()                            │ │
│ │ print(result)                                                            │ │
│ │ ```                                                                      │ │
│ └──────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│ 步骤 3: 执行代码                                                               │
│ ┌────────────────────────────────┐    ┌────────────────────────────────────┐ │
│ │ 成功?                          │    │ 输出:                               │ │
│ │   是 ───────────────────────────────▶ Region                             │ │
│ │                                │    │ East     1523.45                   │ │
│ │                                │    │ West     1821.30                   │ │
│ │                                │    │ ...                                │ │
│ └────────────────────────────────┘    └────────────────────────────────────┘ │
│                 │ 否                                                         │
│                 ▼                                                            │
│ ┌──────────────────────────────────────────────────────────────────────────┐ │
│ │ 错误反馈循环 (最多重试 3 次)                                                 │ │ 
│ │   1. 分类错误类型 (KeyError, TypeError 等)                                 │ │ 
│ │   2. 生成针对性修复建议                                                     │ │
│ │   3. 将错误上下文发回 LLM                                                   │ │
│ │   4. LLM 生成修正后的代码                                                   │ │
│ │   5. 重新执行                                                             │ │
│ └──────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌──────────────────────────────────────────────────────────────────────────────┐
│ 步骤 4: 生成解释                                                               │
│ ┌──────────────────────────────────────────────────────────────────────────┐ │
│ │ LLM 用自然语言总结分析结果                                                   │ │
│ └──────────────────────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                         展示给用户
```

---

## 核心设计决策

### 1. 错误反馈循环

**为什么需要？** LLM 生成的代码偶尔会有错误（列名错误、类型不匹配、语法错误）。我们不是直接报错，而是：

```python
for attempt in range(max_retries):  # 默认: 3 次
    code = llm.generate(messages)
    result = executor.execute(code)

    if result.success:
        return result

    # 分类错误并构建针对性反馈
    error_info = ErrorClassifier.classify(result.error)
    hint = ErrorClassifier.get_hint(error_info)
    # 例如: "找不到列 'Sales'。可用列: ['Revenue', 'Quantity']"

    # 添加错误上下文用于下次尝试
    messages.append({"role": "user", "content": error_context})
```

**好处：**
- **更高成功率**：很多错误通过适当反馈可以修复
- **更好的用户体验**：用户无需手动调试 LLM 生成的代码
- **学习机会**：错误上下文帮助 LLM 更好地理解数据

### 2. 错误分类

我们将错误分为 8 种类型，并给出针对性建议：

| 错误类型 | 示例 | 建议 |
|----------|------|------|
| `KEY_ERROR` | `KeyError: 'Sales'` | 检查列名，展示可用列 |
| `TYPE_ERROR` | `TypeError: cannot convert...` | 建议使用 `astype()`, `pd.to_numeric()` |
| `VALUE_ERROR` | `ValueError: could not convert '$1,234'` | 建议数据清洗（去除 `$`, `,`） |
| `SYNTAX_ERROR` | `SyntaxError: invalid syntax` | 检查括号、缩进 |
| `NAME_ERROR` | `NameError: name 'x' is not defined` | 检查变量是否定义 |
| `INDEX_ERROR` | `IndexError: list index out of range` | 检查数据长度 |
| `ATTRIBUTE_ERROR` | `AttributeError: 'DataFrame' has no...` | 检查对象类型和方法 |
| `IMPORT_ERROR` | `ModuleNotFoundError: No module...` | 使用已导入的库 |

### 3. 模块化 LLM 层

**为什么要抽象 LLM？** 不同的 LLM 有不同的 API、限速和能力。我们的设计：

```python
class BaseLLM(ABC):
    @abstractmethod
    def chat(self, messages: list[dict]) -> str:
        pass

class QwenLLM(BaseLLM):      # 通义千问 API
class OpenAILLM(BaseLLM):    # OpenAI API
class DeepSeekLLM(BaseLLM):  # OpenAI 兼容 API
```

**好处：**
- **易于切换**：一行代码切换模型
- **易于扩展**：实现 `BaseLLM` 即可添加新模型
- **便于测试**：可以 mock LLM 进行单元测试

### 4. 沙箱执行

代码在受控环境中运行：
- 预导入的库（`pandas`, `matplotlib`）
- 捕获 stdout/stderr
- 自动保存图表
- 限制文件系统访问

---

## 项目结构

```
CsvDataAnalyzer/
├── app.py                      # Gradio Web 界面
├── analyzer.py                 # 核心调度器 (CSVAnalyzer)
├── config.py                   # 配置管理
│
├── llm/                        # LLM 抽象层
│   ├── base.py                 # 抽象基类
│   ├── qwen.py                 # 通义千问实现
│   ├── openai_llm.py           # OpenAI 实现
│   └── deepseek.py             # DeepSeek 实现
│
├── core/                       # 核心执行组件
│   ├── executor.py             # 沙箱代码执行器
│   ├── error_handler.py        # 错误分类与建议
│   └── prompts.py              # 提示词模板
│
├── tests/                      # 测试套件
│   ├── test_error_handler.py   # 错误处理单元测试
│   └── test_error_correction_flow.py  # 集成测试
│
├── history/                    # 保存的对话 (自动生成)
├── outputs/                    # 生成的图表 (自动生成)
└── data/                       # 示例 CSV 文件
```

---

## 快速开始

### 环境要求

- Python 3.10+
- 至少一个 LLM 提供商的 API Key

### 安装

```bash
# 克隆仓库
git clone <repo-url>
cd CsvDataAnalyzer

# 创建虚拟环境
python3 -m venv venv
source venv/bin/activate  # Windows: .\venv\Scripts\activate

# 安装依赖
pip install -r requirements.txt

# 配置 API Key
cp .env.example .env
# 编辑 .env 文件，填入你的 API Key
```

### 配置

编辑 `.env` 文件：

```bash
# 至少配置其中一个
DASHSCOPE_API_KEY=your_qwen_key      # 通义千问
OPENAI_API_KEY=your_openai_key       # OpenAI
DEEPSEEK_API_KEY=your_deepseek_key   # DeepSeek
```

### 运行应用

```bash
source venv/bin/activate
python app.py
# 浏览器打开 http://localhost:7860
```

### 运行测试

```bash
source venv/bin/activate

# 单元测试
python -m unittest tests/test_error_handler.py -v

# 集成测试（错误纠正流程）
python tests/test_error_correction_flow.py --fail-count 2
```

### 在 UI 中测试错误纠正

1. 上传一个 CSV 文件
2. 展开左侧「测试模式」面板
3. 勾选「启用错误注入」
4. 设置失败次数（1-2）
5. 发送任意问题，观察错误纠正过程

---

## 使用示例

上传销售数据 CSV，尝试以下问题：

```
1. 分析 Clothing 随时间变化的总销售额趋势
2. 对 bikes 进行同样的分析
3. 哪些年份 components 比 accessories 的总销售额高?
4. "哪个产品类别的平均销售额最高？"
5. "对比 2022 和 2023 年的销售情况"
```

---
## 技术栈

| 组件 | 技术 |
|------|------|
| 前端 | Gradio 4.x |
| 大模型 | 通义千问 / OpenAI / DeepSeek |
| 数据处理 | Pandas |
| 可视化 | Matplotlib |
| 配置管理 | python-dotenv |

---

## 许可证

MIT
